--8장 조인
--8-1 카티션 곱
SELECT *  FROM EMP;  --14건
SELECT * FROM DEPT; --4건
SELECT 14*4 FROM DUAL; --56건 
SELECT *
  FROM EMP, DEPT
 ORDER BY EMPNO;  --56건  모든 경우의 수 전부 출력해버림
 
--8-2 동등조인
SELECT *
  FROM EMP, DEPT
 WHERE EMP.DEPTNO = DEPT.DEPTNO  --해당하는 부서정보만 연결해서 나머지 경우의수 제외하고
 ORDER BY EMPNO;  --14건만 출력

--8-3 
SELECT E.EMPNO, E.ENAME, D.DNAME, D.DEPTNO --DEPTNO처럼 양쪽 테이블에 다 있는 명칭은 위치 명시 안하면 에러
  FROM EMP E, DEPT D
 WHERE E.DEPTNO = D.DEPTNO
 ORDER BY E.EMPNO;

SELECT * --10건
  FROM JOBS J, JOB_HISTORY H
 WHERE J.JOB_ID = H. JOB_ID;

SELECT J.JOB_ID, J.JOB_TITLE --관련항목 모두 보기 21건
     , H.START_DATE, H.END_DATE
  FROM JOBS J, JOB_HISTORY H
 WHERE J.JOB_ID = H. JOB_ID(+);

SELECT JOB_ID, MIN(START_DATE) START_DATE
     , MAX(END_DATE) MAX_DATE
  FROM JOB_HISTORY
 GROUP BY JOB_ID;

SELECT J.JOB_ID, J.JOB_TITLE 
     , H.START_DATE, H.END_DATE
  FROM JOBS J
     , (SELECT JOB_ID
         , MIN(START_DATE) START_DATE
         , MAX(END_DATE) END_DATE
            FROM JOB_HISTORY
            GROUP BY JOB_ID) H
 WHERE J.JOB_ID = H. JOB_ID(+);

SELECT COUNT(*) FROM JOBS;

SELECT * FROM DEPARTMENTS;

SELECT E.EMPLOYEE_ID, E.FIRST_NAME, E.LAST_NAME
     , D.DEPARTMENT_NAME
  FROM EMPLOYEES E, DEPARTMENTS D
 WHERE E.DEPARTMENT_ID = D.DEPARTMENT_ID(+);--(+)=조인되지 못한 NULL도 불러옴

SELECT *
  FROM LOCATIONS L;

SELECT *
  FROM COUNTRIES;
  
SELECT *
  FROM LOCATIONS L, COUNTRIES C
 WHERE L.COUNTRY_ID = C.COUNTRY_ID; --동등 조인

--8-4 두 테이블에서 국가코드가 같은 이름
-- 주의: 열의 정의가 애매합니다 테이블 지정.컬럼명
SELECT L.LOCATION_ID
     , C.COUNTRY_ID, C.COUNTRY_NAME
  FROM LOCATIONS L, COUNTRIES C
 WHERE L.COUNTRY_ID = C.COUNTRY_ID;--동등조인

--8-5
SELECT EMPNO, ENAME, D.DEPTNO, DNAME, LOC --DEPTNO는 양쪽다 있기 때문에 위치 명시 필요  (그래도 명시적으로 써주는게 더 좋음)
  FROM EMP E, DEPT D
 WHERE E.DEPTNO =D.DEPTNO
 ORDER BY D.DEPTNO, E.EMPNO;

SELECT E.EMPNO, E.ENAME, D.DEPTNO, D.DNAME, D.LOC --DEPTNO는 양쪽다 있기 때문에 위치 명시 필요  (그래도 명시적으로 써주는게 더 좋음)
  FROM EMP E, DEPT D
 WHERE E.DEPTNO =D.DEPTNO
 ORDER BY D.DEPTNO, E.EMPNO;

--8-6 --급여가 300이상인 직원정보와 부서정보
SELECT E.EMPNO, E.ENAME, D.DEPTNO, D.DNAME, D.LOC 
  FROM EMP E, DEPT D
 WHERE E.DEPTNO =D.DEPTNO
 AND E.SAL >= 3000;

--1분 복습 EMP, DEPT 조인 했을때
--급여가 2500이하이고 사원번호가 9999이하인 정보 출력
SELECT E.EMPNO, E.ENAME, E.SAL, E.DEPTNO
     , D.DNAME, D.LOC
     
  FROM  EMP E, DEPT D
 WHERE E.DEPTNO = D.DEPTNO  --조인 
   AND E.SAL <= 2500 
   AND E.DEPTNO <= 9999
 ORDER BY E.EMPNO;

--비등가 조인: 등가조인 이외 방식
--8-7급여범위를 지정하는 조건식으로 조인
SELECT * FROM SALGRADE;--등급
SELECT * FROM EMP;--등급 외 정보

SELECT *
  FROM EMP E, SALGRADE S
 WHERE E.SAL BETWEEN S.LOSAL AND S.HISAL;

SELECT *
  FROM EMPLOYEES E, JOBS J
 WHERE E.SALARY BETWEEN J.MIN_SALARY AND J.MAX_SALARY;
 
SELECT *
  FROM EMPLOYEES E, JOB_HISTORY H
 WHERE E.HIRE_DATE BETWEEN H.START_DATE AND H.END_DATE;

--자체 조인(셀프 조인)
SELECT *
  FROM EMP E;

SELECT E.EMPNO, E.ENAME 사원명, M.ENAME 관리자명
  FROM EMP E, EMP M
 WHERE E.MGR = M.EMPNO;

SELECT E.EMPLOYEE_ID, E.FIRST_NAME || ' ' || E.LAST_NAME 사원명
     , E.MANAGER_ID, M.FIRST_NAME || ' ' || M.LAST_NAME 관리자명
  FROM EMPLOYEES E, EMPLOYEES M
 WHERE E.MANAGER_ID =M.EMPLOYEE_ID;


--8-9 --14명 외부조인 직원정보 위주 모두
SELECT E.EMPNO, E.ENAME 사원명, M.ENAME 관리자명
  FROM EMP E, EMP M
 WHERE E.MGR = M.EMPNO(+);--LEFT OUTER JOIN

SELECT E.EMPNO, E.ENAME 사원명 FROM EMP E;

--8-10
SELECT E.EMPNO, E.ENAME 사원명, M.ENAME 관리자명
  FROM EMP E, EMP M
 WHERE E.MGR(+) = M.EMPNO;--+가 있는곳 기준으로 NULL값까지 보여줌  RIGHT OUTER JOIN
 
 --FULL OUTER JOIN =(=합집합) UNION 집함연산자 사용
 --INNER JION = 교집합
 --문제
SELECT C.COUNTRY_NAME, L.STATE_PROVINCE, L.STREET_ADDRESS
  FROM COUNTRIES C, LOCATIONS L
 WHERE C.COUNTRY_ID = L.COUNTRY_ID;

SELECT J.JOB_ID, J.JOB_TITLE
     , H.START_DATE, H.END_DATE
  FROM JOBS J, JOB_HISTORY H
 WHERE J.JOB_ID = H.JOB_ID;
 
SELECT E.FIRST_NAME, E.LAST_NAME, D.DEPARTMENT_NAME, J.JOB_TITLE
  FROM EMPLOYEES E, DEPARTMENTS D, JOBS J
 WHERE E.DEPARTMENT_ID = D.DEPARTMENT_ID
   AND E.JOB_ID = J.JOB_ID;
 
SELECT C.COUNTRY_ID, C.COUNTRY_NAME, L.CITY
  FROM COUNTRIES C, LOCATIONS L
 WHERE C.COUNTRY_ID = L.COUNTRY_ID(+)
 ORDER BY C.COUNTRY_ID;

SELECT L.LOCATION_ID, L.CITY, L.COUNTRY_ID
  FROM LOCATIONS L, COUNTRIES C
 WHERE L.COUNTRY_ID = C.COUNTRY_ID;
 
SELECT E.EMPLOYEE_ID, E.FIRST_NAME, E.LAST_NAME,E.DEPARTMENT_ID
     , D.DEPARTMENT_NAME
  FROM EMPLOYEES E, DEPARTMENTS D
 WHERE E.DEPARTMENT_ID = D.DEPARTMENT_ID(+)
 ORDER BY E.EMPLOYEE_ID;
   
SELECT E.FIRST_NAME || ' ' || E.LAST_NAME 직원명
     , M.fIRST_NAME || ' ' || M.LAST_NAME 관리자명
  FROM EMPLOYEES E, EMPLOYEES M
 WHERE E.MANAGER_ID = M.EMPLOYEE_ID(+)
 ORDER BY E.EMPLOYEE_ID;

--SQL-99문법
--NATHRAL JOIN : 등가 조인 대신 할수있는 표준 SQL
SELECT E.EMPNO, E.ENAME, E.JOB, E.MGR, E.HIREDATE
     , E.SAL, E.COMM,DEPTNO, D.DNAME, D.LOC
  FROM EMP E NATURAL JOIN DEPT D  --DEPTNO 오히려 위치 명시해주면 오류남
 ORDER BY DEPTNO, E.EMPNO;

--JOIN ~ USING
SELECT E.EMPNO, E.ENAME, E.JOB, E.MGR, E.HIREDATE
     , E.SAL, E.COMM, DEPTNO, D.DNAME, D.LOC
  FROM EMP E JOIN DEPT D USING(DEPTNO)
 WHERE SAL >=3000
 ORDER BY DEPTNO, E.EMPNO; 
 
--JOIN ~ ON 
SELECT E.EMPNO, E.ENAME, E.JOB, E.MGR, E.HIREDATE
     , E.SAL, E.COMM, E.DEPTNO, D.DNAME, D.LOC
  FROM EMP E JOIN DEPT D ON(E.DEPTNO = D.DEPTNO)
 WHERE SAL >= 3000
 ORDER BY E.DEPTNO, E.EMPNO; 
--외부조인
SELECT E.EMPNO, E.ENAME, E.MGR, M.ENAME 관리자명
  FROM EMP E, EMP M
 WHERE E.MGR = M.EMPNO(+);

--8-14 SQL-99 외부조인
SELECT E.EMPNO, E.ENAME, E.MGR, M.ENAME 관리자명
  FROM EMP E LEFT OUTER JOIN EMP M ON(E.MGR = M.EMPNO); --14건

SELECT E.EMPNO, E.ENAME, E.MGR, M.ENAME 관리자명, D.DNAME
  FROM EMP E LEFT OUTER JOIN EMP M ON(E.MGR = M.EMPNO)
  JOIN DEPT D ON (E.DEPTNO = D.DEPTNO);
   
SELECT E.EMPNO, E.ENAME, E.MGR, M.ENAME 관리자명
  FROM EMP E RIGHT OUTER JOIN EMP M ON(E.MGR = M.EMPNO);--21건
  
SELECT E.EMPNO, E.ENAME, E.MGR, M.ENAME 관리자명
  FROM EMP E FULL OUTER JOIN EMP M ON(E.MGR = M.EMPNO);--22건 
  
--SQL-99 1분 복습
--JOIN ~ USING EMP, DEPT 조인 SQL99  DEPTNO
--급여는 3000이상이며 직속 상관이 반드시 있어야 합니다
SELECT E.EMPNO, E.ENAME, E.JOB, E.MGR, E.HIREDATE, E.SAL, E.COMM
     , D.DNAME, D.LOC
  FROM EMP E JOIN DEPT D USING(DEPTNO)
 WHERE SAL >=3000 AND E.MGR IS NOT NULL
 ORDER BY DEPTNO, E.EMPNO;

--239P
--1-1
SELECT E.DEPTNO, D.DNAME, E.EMPNO, E.ENAME, E.SAL
  FROM EMP E, DEPT D
 WHERE E.DEPTNO = D.DEPTNO
   AND E.SAL > 2000
 ORDER BY E.DEPTNO;
--1-2 
SELECT DEPTNO, D.DNAME, E.EMPNO, E.ENAME, E.SAL
  FROM EMP E JOIN DEPT D USING(DEPTNO)
 WHERE SAL > 2000
 ORDER BY DEPTNO;

SELECT DEPTNO, D.DNAME, E.EMPNO, E.ENAME, E.SAL
  FROM EMP E NATURAL JOIN DEPT D
 WHERE E.SAL > 2000
 ORDER BY DEPTNO;
--2-1
SELECT E.DEPTNO, D.DNAME
     , TRUNC(AVG(E.SAL)) AS AVG_SAL
     , MAX(E.SAL) AS MAS_SAL
     , MIN(E.SAL) AS MIN_SAL
     , COUNT(*) AS CNT
  FROM EMP E, DEPT D
 WHERE E.DEPTNO = D.DEPTNO
 GROUP BY E.DEPTNO, D.DNAME;
--2-2
SELECT E.DEPTNO, D.DNAME
     , TRUNC(AVG(E.SAL)) AS AVG_SAL
     , MAX(E.SAL) AS MAS_SAL
     , MIN(E.SAL) AS MIN_SAL
     , COUNT(*) AS CNT
  FROM EMP E JOIN DEPT D ON(E.DEPTNO = D.DEPTNO)
 GROUP BY E.DEPTNO, D.DNAME;
 
SELECT DEPTNO, D.DNAME
     , TRUNC(AVG(E.SAL)) AS AVG_SAL
     , MAX(E.SAL) AS MAS_SAL
     , MIN(E.SAL) AS MIN_SAL
     , COUNT(*) AS CNT
  FROM EMP E JOIN DEPT D USING(DEPTNO)
 GROUP BY DEPTNO, D.DNAME;
--3-1
SELECT D.DEPTNO, D.DNAME, E.EMPNO, E.ENAME, E.JOB, E.SAL
  FROM EMP E, DEPT D
 WHERE D.DEPTNO = E.DEPTNO(+)
 ORDER BY E.DEPTNO, D.DNAME;
--3-2 
SELECT D.DEPTNO, D.DNAME, E.EMPNO, E.ENAME, E.JOB, E.SAL
  FROM EMP E RIGHT OUTER JOIN DEPT D ON(D.DEPTNO = E.DEPTNO)
 ORDER BY D.DEPTNO, DNAME;
--4-1
SELECT D.DEPTNO, D.DNAME
     , E.EMPNO, E.ENAME, E.MGR, E.SAL, E.DEPTNO
     , S.LOSAL, S.HISAL, S.GRADE
     , M.EMPNO AS MGR_EMPNO
     , M.ENAME AS MGR_NAME
  FROM DEPT D, EMP E, EMP M, SALGRADE S
 WHERE D.DEPTNO = E.DEPTNO(+)
   AND E.MGR = M.EMPNO(+)
   AND E.SAL BETWEEN S.LOSAL(+) AND S.HISAL(+)--NULL값있는곳은 모두 (+) 넣어야 출력됨
 ORDER BY D.DEPTNO, E.EMPNO;
--4-2
SELECT D.DEPTNO, D.DNAME
     , E.EMPNO, E.ENAME, E.MGR, E.SAL, E.DEPTNO
     , S.LOSAL, S.HISAL, S.GRADE
     , M.EMPNO AS MGR_EMPNO
     , M.ENAME AS MGR_NAME
  FROM EMP E RIGHT OUTER JOIN DEPT D ON(E.DEPTNO = D.DEPTNO) 
       LEFT OUTER JOIN SALGRADE S ON(E.SAL BETWEEN S.LOSAL AND S.HISAL)
       LEFT OUTER JOIN EMP M ON(E.MGR = M.EMPNO)
 ORDER BY D.DEPTNO, E.EMPNO;

SELECT D.DEPTNO, D.DNAME
     , E.EMPNO, E.ENAME, E.MGR, E.SAL, E.DEPTNO
     , S.LOSAL, S.HISAL, S.GRADE
     , M.EMPNO AS MGR_EMPNO
     , M.ENAME AS MGR_NAME
  FROM DEPT D LEFT OUTER JOIN EMP E ON(D.DEPTNO = E.DEPTNO) 
       LEFT OUTER JOIN SALGRADE S ON(E.SAL BETWEEN S.LOSAL AND S.HISAL)
       LEFT OUTER JOIN EMP M ON(E.MGR = M.EMPNO)
 ORDER BY D.DEPTNO, E.EMPNO;